/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * RunRunConsole.java
 *
 * Created on 2011-aug-13, 14:44:51
 */

package net.steamingbeans.runrun.ui;

import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.io.InputStream;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import javax.swing.JMenuItem;
import javax.swing.JPopupMenu;
import javax.swing.SwingUtilities;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import org.apache.felix.service.command.CommandSession;
import org.apache.felix.service.command.Converter;

/**
 *
 * @author Per-Erik
 */
public class RunRunConsole extends javax.swing.JFrame {

    private final CommandSession session;
    private List<String> commandList = new LinkedList<String>();
    private ListIterator<String> commandIterator = commandList.listIterator();
    private final String stopCommand;
    private final Output output;
    private boolean skipFirstCommand = true;
    private CommandListCommand lastCommandListCommandWas;
    private JPopupMenu popup;
    private Runnable inputFieldFocusRunner = new Runnable() {
        @Override
        public void run() {
            inputField.requestFocusInWindow();
        }
    };
    private enum CommandListCommand {
        NEXT,
        PREVIOUS,
    }
    private class Output extends StdOutReader {
        public Output(InputStream is) {
            super(is);
        }

        @Override
        public void output(String string) {
            StringBuilder builder = new StringBuilder();
            builder.append(outputArea.getText());
            builder.append(string);
            builder.append("\n");
            outputArea.setText(builder.toString());
        }

        @Override
        public void output(Throwable t) {
            RunRunConsole.this.output(t);
        }
        
    };

    public RunRunConsole(InputStream toEcho, CommandSession session, String stopCommand) {
        super("RunRun Cover");
        commandList.add(""); //Add an initial "empty" command to be able to cycle through to an empty input-line
        this.session = session;
        this.stopCommand = stopCommand;
        initComponents();
        inputField.requestFocusInWindow();
        outputArea.setText("___~~~ Welcome to RunRun Cover ~~~___\nType '" + stopCommand + "' to stop RunRun Cover.\n");
        output = new Output(toEcho);
        output.execute();
        popup = new JPopupMenu();
        popup.add(new JMenuItem("foo"));
        popup.add(new JMenuItem("bar"));
        popup.add(new JMenuItem("baz"));
        popup.addPopupMenuListener(new PopupMenuListener() {
            @Override public void popupMenuWillBecomeVisible(PopupMenuEvent e) {}
            @Override public void popupMenuCanceled(PopupMenuEvent e) {}
            @Override
            public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {
                SwingUtilities.invokeLater(inputFieldFocusRunner);
            }
        });
    }

    @Override
    public void dispose() {
        output.dispose();
        super.dispose();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        mainPanel = new javax.swing.JPanel();
        outputPanel = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        outputArea = new javax.swing.JTextArea();
        inputPanel = new javax.swing.JPanel();
        inputField = new javax.swing.JTextField();
        jLabel1 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
        setBackground(new java.awt.Color(0, 0, 0));
        setFont(new java.awt.Font("Lucida Console", 0, 13)); // NOI18N

        mainPanel.setBackground(new java.awt.Color(0, 0, 0));
        mainPanel.setLayout(new java.awt.BorderLayout());

        jScrollPane1.setBorder(null);

        outputArea.setBackground(new java.awt.Color(0, 0, 0));
        outputArea.setColumns(40);
        outputArea.setEditable(false);
        outputArea.setFont(new java.awt.Font("Lucida Console", 0, 13)); // NOI18N
        outputArea.setForeground(new java.awt.Color(215, 215, 215));
        outputArea.setRows(5);
        outputArea.setTabSize(4);
        outputArea.setBorder(null);
        outputArea.setCaretColor(new java.awt.Color(255, 255, 255));
        outputArea.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        outputArea.setDragEnabled(true);
        outputArea.setSelectionColor(new java.awt.Color(204, 204, 204));
        outputArea.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                outputAreaMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                outputAreaMouseReleased(evt);
            }
        });
        jScrollPane1.setViewportView(outputArea);

        javax.swing.GroupLayout outputPanelLayout = new javax.swing.GroupLayout(outputPanel);
        outputPanel.setLayout(outputPanelLayout);
        outputPanelLayout.setHorizontalGroup(
            outputPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 599, Short.MAX_VALUE)
        );
        outputPanelLayout.setVerticalGroup(
            outputPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 328, Short.MAX_VALUE)
        );

        mainPanel.add(outputPanel, java.awt.BorderLayout.CENTER);

        inputPanel.setBackground(new java.awt.Color(0, 0, 0));

        inputField.setBackground(new java.awt.Color(0, 0, 0));
        inputField.setFont(new java.awt.Font("Lucida Console", 0, 13)); // NOI18N
        inputField.setForeground(new java.awt.Color(215, 215, 215));
        inputField.setBorder(null);
        inputField.setCaretColor(new java.awt.Color(255, 255, 255));
        inputField.setCursor(new java.awt.Cursor(java.awt.Cursor.TEXT_CURSOR));
        inputField.setSelectionColor(new java.awt.Color(204, 204, 204));
        inputField.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                inputFieldKeyReleased(evt);
            }
        });

        jLabel1.setBackground(new java.awt.Color(0, 0, 0));
        jLabel1.setFont(new java.awt.Font("Lucida Console", 0, 13)); // NOI18N
        jLabel1.setForeground(new java.awt.Color(215, 215, 215));
        jLabel1.setText("r!");

        javax.swing.GroupLayout inputPanelLayout = new javax.swing.GroupLayout(inputPanel);
        inputPanel.setLayout(inputPanelLayout);
        inputPanelLayout.setHorizontalGroup(
            inputPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(inputPanelLayout.createSequentialGroup()
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(inputField, javax.swing.GroupLayout.DEFAULT_SIZE, 579, Short.MAX_VALUE))
        );
        inputPanelLayout.setVerticalGroup(
            inputPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(inputPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                .addComponent(jLabel1)
                .addComponent(inputField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        mainPanel.add(inputPanel, java.awt.BorderLayout.PAGE_END);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(mainPanel, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 599, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(mainPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 342, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void inputFieldKeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_inputFieldKeyReleased
        String command = inputField.getText();
        switch(evt.getKeyCode()) {
            case KeyEvent.VK_ENTER:
                processCommand(command);
                break;
            case KeyEvent.VK_DOWN: //next
                String next = processCommandListCommand(CommandListCommand.NEXT);
                inputField.setText(next);
                break;
            case KeyEvent.VK_UP: //previous
                String previous = processCommandListCommand(CommandListCommand.PREVIOUS);
                inputField.setText(previous);
                break;
            default:
                break;
        }
    }//GEN-LAST:event_inputFieldKeyReleased

    private void outputAreaMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_outputAreaMouseReleased
        if(evt.isPopupTrigger()) {
            showPopup(evt.getPoint());
        } else if(outputArea.getSelectedText() == null || outputArea.getSelectedText().isEmpty()) {
            inputField.requestFocusInWindow();
        }
    }//GEN-LAST:event_outputAreaMouseReleased

    private void outputAreaMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_outputAreaMousePressed
        if(evt.isPopupTrigger()) {
            showPopup(evt.getPoint());
        }
    }//GEN-LAST:event_outputAreaMousePressed

    private void showPopup(Point p) {
        popup.show(outputArea, p.x, p.y);
    }

    private String processCommandListCommand(CommandListCommand listCommand) {
        String command;
        if(listCommand == CommandListCommand.NEXT) {
            if(commandIterator.hasNext()) {
                command = commandIterator.next();
            } else {
                commandIterator = commandList.listIterator(0);
                command = commandIterator.next(); //This is safe because there will always be at least one element in the list
            }
            if(lastCommandListCommandWas == CommandListCommand.PREVIOUS) {
                // (1)
                lastCommandListCommandWas = CommandListCommand.NEXT;
                command = processCommandListCommand(CommandListCommand.NEXT);
            } else {
                lastCommandListCommandWas = CommandListCommand.NEXT;
            }
        } else {
            if(commandIterator.hasPrevious()) {
                command = commandIterator.previous();
            } else {
                commandIterator = commandList.listIterator(commandList.size());
                command = commandIterator.previous(); //This is safe because there will always be at least one element in the list
            }
            if(lastCommandListCommandWas == CommandListCommand.NEXT) {
                // (1)
                lastCommandListCommandWas = CommandListCommand.PREVIOUS;
                command = processCommandListCommand(CommandListCommand.PREVIOUS);
            } else {
                lastCommandListCommandWas = CommandListCommand.PREVIOUS;
            }
        }
        return command;
        /* (1) explanation:
         * If we say "next" and then "previous" we end up at the same place. To
         * avoid this and "skip" the element we're at, say "next->next" if
         * last list command was previous and vice versa.
         * Ex:
         * [A, B, C]
         *  ^
         * next gives
         * [A, B, C]
         *     ^
         * Since iterators work as they do, a call to previous would now yield
         * [A, B, C]
         *     ^
         * Not what we want!
         */
    }

    private void processCommand(String command) {
        inputField.setText("");
        //Handle command list
        if(!command.isEmpty()) { //Dont add empty commands to command list
            String lastGivenCommand = commandList.get(commandList.size() - 1);
            if(!command.equals(lastGivenCommand)) { //Dont add same command directly after each other
                commandList.add(command);
                if(commandList.size() > 10) { //Dont add more than 10 commands to the command list
                    commandList.remove(0);
                }
                commandIterator = commandList.listIterator(); //Reset iterator upon adding new commands to command list
            }
        }
        //Execute command
        try {
            if(!skipFirstCommand) {
                output("r! " + command + "\n");
                if(!processInternal(command)) {
                    Object result = session.execute(command);
                    if(result != null) {
                        output(result);
                    }
                }
            } else {
                skipFirstCommand = false;
            }
        } catch (Exception ex) {
            output(ex);
        }
    }

    private boolean processInternal(String command) throws Exception {
        if(command.equals("cls") || command.equals("clear")) {
            outputArea.setText("");
            return true;
        } else if(command.startsWith("exit") || command.startsWith("system:exit")) {
            outputArea.setText("");
            session.execute(stopCommand);
        }
        return false;
    }

    private void output(Object o) {
        CharSequence seq = session.format(o, Converter.INSPECT);
        output(seq.toString());
    }

    private void output(String s) {
        StringBuilder builder = new StringBuilder();
        builder.append(outputArea.getText());
        builder.append(s);
        outputArea.setText(builder.toString());
    }

    private void output(Throwable thrown) {
        StringBuilder builder = new StringBuilder();
        builder.append(outputArea.getText());
        //The CommandNotFoundException is not exported through the api of gogo.
        //This is an ugly hack until (if ever) the class is exported.
        if(thrown instanceof IllegalArgumentException && thrown.getClass().getName().contains("CommandNotFoundException")) {
            builder.append(thrown.getMessage());
            builder.append("\n");
        } else {
            builder.append(thrown.getClass().getName());
            builder.append(thrown.getMessage());
            builder.append("\n");
            for(StackTraceElement elem : thrown.getStackTrace()) {
                builder.append("\t");
                builder.append(elem.toString());
                builder.append("\n");
            }
        }
        outputArea.setText(builder.toString());
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField inputField;
    private javax.swing.JPanel inputPanel;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JPanel mainPanel;
    private javax.swing.JTextArea outputArea;
    private javax.swing.JPanel outputPanel;
    // End of variables declaration//GEN-END:variables

}
